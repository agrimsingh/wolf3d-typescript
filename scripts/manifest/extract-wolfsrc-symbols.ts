import { readdirSync, readFileSync, mkdirSync, writeFileSync } from 'node:fs';
import { join, extname, basename, resolve } from 'node:path';

type PhaseName =
  | 'phase-1-math'
  | 'phase-2-map'
  | 'phase-3-raycast'
  | 'phase-4-ai'
  | 'phase-5-player'
  | 'phase-6-gamestate'
  | 'phase-7-menu-text'
  | 'phase-8-audio'
  | 'shared';

interface SymbolEntry {
  file: string;
  functionName: string;
  returnType: string;
  signature: string;
  line: number;
  phases: PhaseName[];
  primaryPhase: PhaseName;
}

const projectRoot = resolve(process.cwd());
const wolfsrc = resolve('/Users/agrim/Downloads/ai fun projects/wolf3d-master/WOLFSRC');
const outDir = join(projectRoot, 'specs', 'generated');

const phaseMap: Record<string, PhaseName[]> = {
  'WL_MAIN.C': ['phase-1-math', 'phase-3-raycast'],
  'WL_DRAW.C': ['phase-1-math', 'phase-3-raycast'],
  'WL_SCALE.C': ['phase-3-raycast'],
  'ID_CA.C': ['phase-2-map', 'phase-8-audio'],
  'WL_GAME.C': ['phase-2-map', 'phase-6-gamestate', 'phase-8-audio'],
  'WL_STATE.C': ['phase-4-ai'],
  'WL_ACT1.C': ['phase-4-ai', 'phase-6-gamestate'],
  'WL_ACT2.C': ['phase-4-ai'],
  'WL_AGENT.C': ['phase-5-player', 'phase-6-gamestate'],
  'WL_PLAY.C': ['phase-5-player'],
  'ID_IN.C': ['phase-5-player'],
  'WL_INTER.C': ['phase-6-gamestate'],
  'WL_MENU.C': ['phase-7-menu-text'],
  'WL_TEXT.C': ['phase-7-menu-text'],
  'ID_US_1.C': ['phase-7-menu-text'],
  'ID_SD.C': ['phase-8-audio'],
};

function primaryPhase(phases: PhaseName[]): PhaseName {
  const order: PhaseName[] = [
    'phase-1-math',
    'phase-2-map',
    'phase-3-raycast',
    'phase-4-ai',
    'phase-5-player',
    'phase-6-gamestate',
    'phase-7-menu-text',
    'phase-8-audio',
    'shared',
  ];
  for (const p of order) {
    if (phases.includes(p)) {
      return p;
    }
  }
  return 'shared';
}

function normalizeType(type: string): string {
  return type.replace(/\s+/g, ' ').replace(/\b(near|far|huge|interrupt|pascal)\b/g, '').replace(/\s+/g, ' ').trim();
}

function extractFromFile(filePath: string): SymbolEntry[] {
  const file = basename(filePath);
  const text = readFileSync(filePath, 'utf8');
  const lines = text.split(/\r?\n/);
  const entries: SymbolEntry[] = [];

  const regex = /(^|\n)\s*([A-Za-z_][A-Za-z0-9_\s\*\t]*?)\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(([^;{}]*)\)\s*\{/g;
  let match: RegExpExecArray | null;

  while ((match = regex.exec(text)) !== null) {
    const returnTypeRaw = match[2] ?? '';
    const fnName = match[3] ?? '';
    const args = (match[4] ?? '').trim();

    if (!fnName || ['if', 'for', 'while', 'switch'].includes(fnName)) {
      continue;
    }

    const returnType = normalizeType(returnTypeRaw);
    if (!returnType || returnType.startsWith('//')) {
      continue;
    }

    const before = text.slice(0, match.index);
    const line = before.split(/\r?\n/).length;

    const phases = phaseMap[file] ?? ['shared'];
    const signature = `${returnType} ${fnName}(${args})`;

    entries.push({
      file,
      functionName: fnName,
      returnType,
      signature,
      line,
      phases,
      primaryPhase: primaryPhase(phases),
    });
  }

  const seen = new Set<string>();
  return entries.filter((entry) => {
    const key = `${entry.file}:${entry.functionName}:${entry.line}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

function toCsv(entries: SymbolEntry[]): string {
  const header = 'file,functionName,returnType,line,primaryPhase,phases,signature';
  const rows = entries.map((e) => {
    const esc = (v: string) => `"${v.replaceAll('"', '""')}"`;
    return [
      esc(e.file),
      esc(e.functionName),
      esc(e.returnType),
      String(e.line),
      esc(e.primaryPhase),
      esc(e.phases.join('|')),
      esc(e.signature),
    ].join(',');
  });
  return `${header}\n${rows.join('\n')}\n`;
}

function toMarkdown(entries: SymbolEntry[]): string {
  const byPhase = new Map<PhaseName, SymbolEntry[]>();
  for (const entry of entries) {
    const arr = byPhase.get(entry.primaryPhase) ?? [];
    arr.push(entry);
    byPhase.set(entry.primaryPhase, arr);
  }

  const phaseOrder: PhaseName[] = [
    'phase-1-math',
    'phase-2-map',
    'phase-3-raycast',
    'phase-4-ai',
    'phase-5-player',
    'phase-6-gamestate',
    'phase-7-menu-text',
    'phase-8-audio',
    'shared',
  ];

  const lines: string[] = [];
  lines.push('# WOLFSRC Port Manifest');
  lines.push('');
  lines.push('Authoritative symbol inventory for full TS port. Generated by `scripts/manifest/extract-wolfsrc-symbols.ts`.');
  lines.push('');
  lines.push('## Generated Outputs');
  lines.push('');
  lines.push('- `specs/generated/wolfsrc-manifest.json`');
  lines.push('- `specs/generated/wolfsrc-manifest.csv`');
  lines.push('');
  lines.push('## Phase Summary');
  lines.push('');
  lines.push('| Phase | Function Count |');
  lines.push('| :--- | ---: |');
  for (const phase of phaseOrder) {
    const count = byPhase.get(phase)?.length ?? 0;
    lines.push(`| ${phase} | ${count} |`);
  }

  lines.push('');
  lines.push('## Port Checklist');
  lines.push('');
  for (const phase of phaseOrder) {
    const phaseEntries = (byPhase.get(phase) ?? []).sort((a, b) => a.file.localeCompare(b.file) || a.functionName.localeCompare(b.functionName));
    lines.push(`### ${phase}`);
    lines.push('');
    if (phaseEntries.length === 0) {
      lines.push('- [ ] No symbols mapped');
      lines.push('');
      continue;
    }
    for (const entry of phaseEntries) {
      lines.push(`- [ ] \`${entry.file}:${entry.functionName}\` (line ${entry.line})`);
    }
    lines.push('');
  }

  return `${lines.join('\n')}\n`;
}

function main(): void {
  const cFiles = readdirSync(wolfsrc)
    .filter((name) => extname(name).toUpperCase() === '.C')
    .map((name) => join(wolfsrc, name));

  let entries: SymbolEntry[] = [];
  for (const filePath of cFiles) {
    entries = entries.concat(extractFromFile(filePath));
  }

  entries.sort((a, b) => a.primaryPhase.localeCompare(b.primaryPhase) || a.file.localeCompare(b.file) || a.functionName.localeCompare(b.functionName) || a.line - b.line);

  mkdirSync(outDir, { recursive: true });

  writeFileSync(join(outDir, 'wolfsrc-manifest.json'), `${JSON.stringify({ generatedAt: new Date().toISOString(), total: entries.length, entries }, null, 2)}\n`, 'utf8');
  writeFileSync(join(outDir, 'wolfsrc-manifest.csv'), toCsv(entries), 'utf8');
  writeFileSync(join(projectRoot, 'specs', 'port-manifest.md'), toMarkdown(entries), 'utf8');

  const counts = new Map<string, number>();
  for (const entry of entries) {
    counts.set(entry.primaryPhase, (counts.get(entry.primaryPhase) ?? 0) + 1);
  }

  const summary = [...counts.entries()].sort(([a], [b]) => a.localeCompare(b)).map(([phase, count]) => `${phase}:${count}`).join(', ');
  console.log(`Generated manifest for ${entries.length} functions (${summary})`);
}

main();
